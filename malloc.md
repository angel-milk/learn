#### TCMalloc:Thread Cache Malloc 线程缓存分配（为什么是线程）
#### golang调度（GPM）
###  G:Goroutine P:Processor M:Machine
+ Goroutine：就是咱们常用的用go关键字创建的执行体，它对应一个结构体g，结构体里保存了goroutine的堆栈信息
+ Machine：表示操作系统的线程
+ Processor：表示处理器，有了它才能建立G、M的联系

#### TCMalloc 性能提升
+ 线程内部小对象使用不存在锁竞争，减少了竞争带来的开销。
+ 内存大对象分配到堆上，采用自旋锁减少休眠唤醒的开销。
#### 内存利用率提升
+ 区分线程，central，heap三级，线程之前有一个共享内存池（central区）。线程内部内存不足时，向central申请，使用完成，归还central，充分利用内存。central区内存不足时，向heap申请，空闲时归还heap。

### 自旋锁 互斥锁

对共享资源加锁阻止并发访问，保证数据一致性。
+ 自旋锁 spinlock：如果获取自旋锁失败，线程会反复获取，直至成功，线程不让出cpu时间，其他线程不能运行。单核等待时间长，线程会阻塞所有线程不能运行。
+ 互斥锁 mutex：当一个线程获取一个互斥锁，该互斥锁被其他线程获取，没有获取到，线程进入休眠状态，让出cpu时间，运行其他线程，等待互斥锁线程释放，唤醒这个线程。线程休眠以及唤醒线程比较昂贵的操作，花费大量cpu指令，花费大量cpu时间。如果等待时间很短，浪费在休眠和唤醒时间会多，降低了系统的性能。

+ 目前现在操作系统支持混合互斥自旋锁，获取锁失败后，不会立即休眠，互斥锁开始自旋锁，等待足够长时间后，线程进行休眠。

#### 内存块
+ span 面向内部管理
+ object 将span按照特定大小切分成多个小块，每个小块存粗一个对象。


### 小对象分配
+ 小对象内存默认分屏170个不同大小的快。
### 大对象分配
+ 大于32k内存申请，使用全局内存（中央堆）分配。全局组织单链表数组，数组长度为256，分别对应1page，2page


### 综述
+ TCMalloc给每个线程分配一个线程局部缓存。小对象的分配直接局部缓存完成，如果缓存不够，向中央数据数据结构申请到局部缓存，定期使用垃圾收集器把内存回收到中央数据结构中。

TCMalloc 将尺寸大小等于32k对象和大于32k对象区分开来。
大对象直接使用页级分配器（page-levelalloctor）

#### 跨度span

TCMalloc管理的堆是由一系列页面组成。一系列连续的页面有一个跨度对象表示（span）。
span分为已被分配或者空闲的。

空闲：跨度则会是一个页面堆列表的一个条目。

已被分配：或者是已经被传递给应用程序的大对象，或者是一个已经被分割成一系列小对象的一个页面。如果是小对象，对象的尺寸会被记录到跨度中。

#### 释放

对象释放->计算对象页面号，在中央数组中查找对应跨度->判断是大对象还是小对象

小对象 ：看尺寸类别，小对象如果尺寸小于线程缓存预订，直接插入线程缓存链表，如果超过，使用垃圾收集器将未使用的线程缓存移入中央自由列表。

大对象 ：返回对象的页面范围，查看2边页面是否空闲，如果空闲是联合起来，跨度会被插入页面堆中空闲链表中。


#### gc
