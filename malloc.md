#### TCMalloc:Thread Cache Malloc 线程缓存分配（为什么是线程）
#### golang调度（GPM）
###  G:Goroutine P:Processor M:Machine
+ Goroutine：就是咱们常用的用go关键字创建的执行体，它对应一个结构体g，结构体里保存了goroutine的堆栈信息
+ Machine：表示操作系统的线程
+ Processor：表示处理器，有了它才能建立G、M的联系

#### TCMalloc 性能提升
+ 线程内部小对象使用不存在锁竞争，减少了竞争带来的开销。
+ 内存大对象分配到堆上，采用自旋锁减少休眠唤醒的开销。
#### 内存利用率提升
+ 区分线程，central，heap三级，线程之前有一个共享内存池（central区）。线程内部内存不足时，向central申请，使用完成，归还central，充分利用内存。central区内存不足时，向heap申请，空闲时归还heap。

### 自旋锁 互斥锁

对共享资源加锁阻止并发访问，保证数据一致性。
+ 自旋锁 spinlock：如果获取自旋锁失败，线程会反复获取，直至成功，线程不让出cpu时间，其他线程不能运行。单核等待时间长，线程会阻塞所有线程不能运行。
+ 互斥锁 mutex：当一个线程获取一个互斥锁，该互斥锁被其他线程获取，没有获取到，线程进入休眠状态，让出cpu时间，运行其他线程，等待互斥锁线程释放，唤醒这个线程。线程休眠以及唤醒线程比较昂贵的操作，花费大量cpu指令，花费大量cpu时间。如果等待时间很短，浪费在休眠和唤醒时间会多，降低了系统的性能。

+ 目前现在操作系统支持混合互斥自旋锁，获取锁失败后，不会立即休眠，互斥锁开始自旋锁，等待足够长时间后，线程进行休眠。

#### 内存块
+ span 面向内部管理
+ object 将span按照特定大小切分成多个小块，每个小块存粗一个对象。


### 小对象分配
+ 小对象内存默认分屏170个不同大小的快。
### 大对象分配
+ 大于32k内存申请，使用全局内存（中央堆）分配。全局组织单链表数组，数组长度为256，分别对应1page，2page


### 综述
+ TCMalloc给每个线程分配一个线程局部缓存。小对象的分配直接局部缓存完成，如果缓存不够，向中央数据数据结构申请到局部缓存，定期使用垃圾收集器把内存回收到中央数据结构中。

TCMalloc 将尺寸大小等于32k对象和大于32k对象区分开来。
大对象直接使用页级分配器（page-levelalloctor）

#### 跨度span

TCMalloc管理的堆是由一系列页面组成。一系列连续的页面有一个跨度对象表示（span）。
span分为已被分配或者空闲的。

空闲：跨度则会是一个页面堆列表的一个条目。

已被分配：或者是已经被传递给应用程序的大对象，或者是一个已经被分割成一系列小对象的一个页面。如果是小对象，对象的尺寸会被记录到跨度中。

#### 释放

对象释放->计算对象页面号，在中央数组中查找对应跨度->判断是大对象还是小对象

小对象 ：看尺寸类别，小对象如果尺寸小于线程缓存预订，直接插入线程缓存链表，如果超过，使用垃圾收集器将未使用的线程缓存移入中央自由列表。

大对象 ：返回对象的页面范围，查看2边页面是否空闲，如果空闲是联合起来，跨度会被插入页面堆中空闲链表中。


#### gc


### 内存逃逸
> runtime/stbus.go 函数noescape\
> 通过指针的动态范围，决定一个变量是否分配到栈上，还是堆上。

#### 为什么分析,避免内存逃逸
> golang编译器，判断变量的生命周期。如果认为在函数结束后，不被外部使用，分配到栈上，否则分配到堆上。\
> 栈上的内存是自动回收清理，且空间有限。堆的上内存需要处理gc，才能达到回收。频繁的gc操作，影响运行性能，所以要减少gc的操作。

#### 常见内存逃逸
1. 局部的遍历指针返回，被外部引用，生命周期大于栈。
2. 发送指针或带有指针的值到channel，编译时无法知道goroutine会在channel接收，编译器无法判断什么时候释放。
3. 切片上存储指针或带有指针的值。如[]string,导致切片内容逃逸，引用值一直在堆上。
4. 切片append导致超出容量，切片重新分配地址，切片背后的存储基于运行的数据进行扩充，就会分配到堆上。
5. interface类型上调用方法，在interface调用方法动态调度，只有在运行时才知道。

#### 如何避免
1. golang接口类型调用时动态的，因此不能在编译确定，高频访问的函数，避免调用接口。
2. 避免使用变量指针作为参数。
3. 预设定好slice的长度，避免频繁超过范围容量，重新分配。

#### 方法
1. go build -gcflags '-m' main.go 查看编译信息
```golang
cmd/ptest.go:139:15: v1 escapes to heap
cmd/ptest.go:139:15: io.Writer(os.Stdout) escapes to heap
cmd/ptest.go:143:15: io.Writer(os.Stdout) escapes to heap
```
2. go tool compile -S 生成汇编
```golang
$ go tool compile -S escape.go | grep escape.go:10
    0x001d 00029 (escape.go:10) PCDATA  $2, $1
    0x001d 00029 (escape.go:10) PCDATA  $0, $0
    0x001d 00029 (escape.go:10) LEAQ    type.int(SB), AX
    0x0024 00036 (escape.go:10) PCDATA  $2, $0
    0x0024 00036 (escape.go:10) MOVQ    AX, (SP)
    0x0028 00040 (escape.go:10) CALL    runtime.newobject(SB)
    0x002d 00045 (escape.go:10) PCDATA  $2, $1
    0x002d 00045 (escape.go:10) MOVQ    8(SP), AX
    0x0032 00050 (escape.go:10) MOVQ    $1, (AX)

    //可以看到，这里的00040有调用runtime.newobject(SB)这个方法，看到这个方法大家就应该懂了！
```
