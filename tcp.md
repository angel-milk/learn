### TCP,UDP区别
* TCP面向连接，可靠的，基于字节流的传输层协议。
> * 面向连接：连接指客户端与服务器的连接，双方互相通信之前，TCP需要3次握手建立连接，而UDP没有建立连接的过程。
> * 可靠性：有状态，可控制保证TCP的连接。（数据包有顺序，不能有差错，有状态。如果数据包丢失了，可以调整速度和重复，可控制）
> * UDP数据传输基于数据报文，继承了ip层特性。TCP维护状态，将一个个ip包变成字节流。

* UDP面向无连接的传输层协议。  

1. 基于连接无连接 
> 1. tcp 传输控制协议：面向连接，可靠的字节流服务。客户端与服务端通信时，建立tcp连接后，才能传输数据。提供超时重发，数据校验，流量控制，保证数据传递。
> 2. udp 数据报文面向无连接：每个数据包含有完整的源，目的地址，分组编号，各自在网络中独立传输，传输中不管其顺序，数据到达后，进行排序组装。如果丢失，差错，失序，可以通过重新请求重发。效率比较高。
2. 系统资源要求:TCP多，UDP少。
3. UDP数据结构简单。
4. TCP流模式，UDP数据包模式
5. TCP保证数据正确性，UDP可能丢包，TCP保证顺序，UDP不保证。
6. TCP是可靠的字节流服务，UDP不提供IP协议可靠机制，流控制，错误恢复功能。

### 三次握手
> 保证客户端和服务端都具有发送和接收能力。(三次握手期间可以携带数据，但建立连接中间，处理数据，消耗时间和内存，增加风险；再无法确定客户端服务发送接收能力正常)
1. 开始都处于close状态，服务端监听端口，处于listen状态(端口监听队列)。
2. 客户端主动发起连接，发送syn(seq=x)，客户端变为syn-send状态。
3. 服务端收到，返回syn(seq=y)，ack=x+1（对应客户端syn），服务端变为syn-send。
4. 客户端收到应答，再次发送ack=y+1,seq=x+1,客户端变为established.
5. 服务端收到ack,状态也变成established。

### 四次挥手
1. 开始服务端客户端都处于estabished状态，数据传输。
2. 客户端要端口，向服务器发送fin（seq=p）报文，发送后变为fin-wait-1状态，同时为half-close状态，无法继续发送报文，只能接收。
3. 服务端接收到fin报文，变为close-wait，返回确认报文ack(ack=p+1).
4. 客户端接收到确认报文，变为fin-wait-2报文。
5. 随后服务端继续发送fin报文ack(ack=p+1)，fin（seq=q）,变为last-ack状态。
6. 客户端收到fin报文，变为time-wait，发送ack（seq=q+1）
7. 客户端等待足够长时间，2个MSL（最大报文生存时间），如果没有收到服务端重发请求，表示ack发送成，挥手结束。否则客户端重新发送ack。
> 2MAL意义：1个MSL确保四次挥手中主动关闭最后ack能给到达服务端。1个MSL确认服务端的没有收到ack重传的fin报文看看可以到大

### 半连接，全连接
1. 客户端发syn到服务端，服务端收到回复ack和syn，listen变为syn—rcvd，连接进入syn队列，半连接队列。
2. 客户端返回ack后，3次握手成功后，建立连接，进入tcp维护的队列，全连接队列。

### syn flood攻击
> dos/ddos攻击，客户端伪造大量不存在ip，像服务端发送syn报文。后果：
> 1. 处理大量syn包，返回ack，大量syn-rcvd状态，占满半连接队列，无法处理正常的连接。
> 2. 不存在ip，服务端收不到客户端的ack，导致不断重发数据，耗费服务端资源。

#### 避免：
1. 增加syn连接，提高半连接队列容量。
2. 减少syn-ack重试次数，避免大量超时重发。
3. syn cookie，接收syn不分配连接资源，根据syn建立cookies，连同第二次握手返回客户端，客户端回复ack带cookies，验证cookies合法，在分配资源。

### TCP头部报文
1. 源端口，目的端口（ip已在ip层处理）
2. 序列号seq，范围（4个字节，32位无符号整数，0-2^32-1）,到达最大值循环到0。syn报文彼此交换序列号；保证数据正确组装。
3. isn: 初始序列号
4. ack：用于告知对付下次期望接收的序列号，小于ack表示均已收到。
5. 标记位：fin：finish标识发送方准备端口。rst：reset，用于强制端口。psh：push，告知对方数据包收到后应交由上层应用，不能缓存。
6. 窗口大小
7. 检验和，2个字节，防止传输过程中数据表有损坏，如遇到校验失败，放弃，等待重传。


### TCP快速打开TFO
1. 首轮三次握手
> 服务端第二次握手返回syn+ack，TFO返回syn cookie，放在TCP报文Fast Open选项中。客户端将cookie缓存
2. 后面三次握手
> 客户端只需将cookie，syn，http请求发送服务端，服务端验证通过，就可以返回返回http相应。客户端接收并发ack，建立连接。

*优势*
> 不在于首轮握手，在于之后得握手，利用1个rtt，往返延时，提前进行数据传输。